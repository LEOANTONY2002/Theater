import {AISettingsManager} from '../store/aiSettings';
import {cache, CACHE_KEYS} from '../utils/cache';
import {searchMovies, searchTVShows} from './tmdb';

// Default fallback values
const DEFAULT_MODEL = 'gemini-2.5-flash';
// const DEFAULT_API_KEY = 'AIzaSyA_up-9FqMhzaUxhSj3wEry5qOELtTva_8';

// Dynamic function to get current settings
const getGeminiConfig = async () => {
  const settings = await AISettingsManager.getSettings();

  try {

    return {
      model: settings.model || DEFAULT_MODEL,
      apiKey: settings.apiKey,
      apiUrl: `https://generativelanguage.googleapis.com/v1beta/models/${
        settings.model || DEFAULT_MODEL
      }:generateContent`,
    };
  } catch (error) {
    console.error('Error getting AI settings, using defaults:', error);
    return {
      model: DEFAULT_MODEL,
      apiKey: settings.apiKey,
      apiUrl: `https://generativelanguage.googleapis.com/v1beta/models/${DEFAULT_MODEL}:generateContent`,
    };
  }
};

interface GeminiMessage {
  role: 'user' | 'model';
  parts: Array<{text: string}>;
}

interface OpenAIMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

// Convert OpenAI-style messages to Gemini format
function convertMessagesToGemini(messages: OpenAIMessage[]): {
  systemInstruction?: {parts: Array<{text: string}>};
  contents: GeminiMessage[];
} {
  const systemMessages = messages.filter(msg => msg.role === 'system');
  const conversationMessages = messages.filter(msg => msg.role !== 'system');

  // Combine system messages
  const systemInstruction =
    systemMessages.length > 0
      ? {
          parts: [
            {
              text: systemMessages.map(msg => msg.content).join('\n\n'),
            },
          ],
        }
      : undefined;

  // Convert conversation messages
  const contents: GeminiMessage[] = conversationMessages.map(msg => ({
    role: msg.role === 'assistant' ? 'model' : 'user',
    parts: [{text: msg.content}],
  }));

  return {systemInstruction, contents};
}

async function callGemini(messages: OpenAIMessage[]): Promise<string> {
  const config = await getGeminiConfig();
  const {systemInstruction, contents} = convertMessagesToGemini(messages);

  const requestBody: any = {
    contents,
    generationConfig: {
      temperature: 0.7,
      topK: 40,
      topP: 0.95,
    },
    safetySettings: [
      {
        category: 'HARM_CATEGORY_HARASSMENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_HATE_SPEECH',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
    ],
  };

  if (systemInstruction) {
    requestBody.systemInstruction = systemInstruction;
  }

  try {
    const response = await fetch(`${config.apiUrl}?key=${config.apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      throw new Error(`${response?.status}`);
    }

    const data = await response.json();

    // Extract the generated text from Gemini response
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!generatedText) {
      throw new Error('No content generated by Gemini');
    }

    return generatedText;
  } catch (error) {
    console.error('Gemini API call failed:', error);
    throw error;
  }
}

// For Movie/Show Details: get similar by story
export async function getSimilarByStory({
  title,
  overview,
  genres,
  type,
}: {
  title: string;
  overview: string;
  genres: string;
  type: 'movie' | 'tv';
}) {
  const cacheKey = `${type}:${title.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`;
  
  // Try to get from cache first
  const cachedResponse = await cache.get(CACHE_KEYS.AI_SIMILAR, cacheKey);
  if (cachedResponse) {
    return cachedResponse;
  }

  const system = {
    role: 'system' as const,
    content: `You are a movie/TV recommender called Theater AI. 
      Given a title, genres and story, give the most similar movie/show. 
      Return a JSON array of title and year up to 5 similar movies or TV shows. 
      Do not include any explanation or extra text. Just return the JSON array.
      Response Format: [{"title": "Title1", "year": "2024"}, {"title": "Title2", "year": "2025"}]`,
  };
  const user = {
    role: 'user' as const,
    content: `Title: ${title}\nStory: ${overview}\nType: ${type}\nGenres: ${genres}`,
  };

  try {
    const result = await callGemini([system, user]);
    
    // Cache the response for 1 week
    if (result) {
      await cache.set(CACHE_KEYS.AI_SIMILAR, cacheKey, result, 7 * 24 * 60 * 60 * 1000);
    }
    
    // Try to extract JSON from the response
    const jsonMatch = result.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0]);
      return Array.isArray(parsed) ? parsed : [];
    }

    // If no JSON array found, try to parse the entire response
    const parsed = JSON.parse(result);
    return Array.isArray(parsed) ? parsed : [];
  } catch (error) {
    console.error('Error parsing Gemini similar response:', error);
    return [];
  }
}

// For Online AI Chat (cinema only)
export async function cinemaChat(
  messages: {role: 'user' | 'assistant' | 'system'; content: string}[],
): Promise<{aiResponse: string; arr: any[]}> {
  // No caching: always compute fresh response for detail screen chats

  const system = {
    role: 'system' as const,
    content: `You are an expert cinema assistant called Theater AI. 
      Only answer questions related to movies, TV, actors, directors, film history, and cinema. 
      Politely refuse unrelated questions. 
      Whenever you suggest any movies/TV shows, always include the tmdb title, year, type in a array only at the last line of the message response.
      whatever the content you are suggesting or talking about should be their correct tmdb details included in the JSON array. And the array should be the last line of the WHOLE RESPONSE, Dont include multiple arrays in every single content.
      JSON Format: [{"title": "Title1", "year": "2024", "type": "movie"}, {"title": "Title2", "year": "2025", "type": "tv"}].
      `,
  };

  const geminiMessages = [system, ...messages];
  try {
    const response = await callGemini(geminiMessages);
    
    let arr = [];

    // Try to extract JSON from the response
    const jsonMatch = response.match(/\[.*?\]/s);
    console.log('jsonMatch', jsonMatch);

    if (jsonMatch) {
      arr = JSON.parse(jsonMatch[0] || '[]');
    }

    // AI Response without JSON
    const aiResponse = response.replace(/\[.*?\]/s, '');

    return {aiResponse, arr};
  } catch (error) {
    console.error('Error in cinemaChat:', error);
    throw error;
  }
}

// For Movie/TV Trivia & Facts
export async function getMovieTrivia({
  title,
  year,
  type,
}: {
  title: string;
  year?: string;
  type: 'movie' | 'tv';
}) {
  // Generate a consistent cache key
  const cacheKey = `trivia:${type}:${title.toLowerCase().replace(/[^a-z0-9]+/g, '-')}${year ? `:${year}` : ''}`;
  
  // Try to get from cache first
  try {
    const cached = await cache.get<string>(CACHE_KEYS.AI_TRIVIA, cacheKey);
    if (cached) {
      // If we have a cached string, parse it
      if (typeof cached === 'string') {
        const parsed = JSON.parse(cached);
        if (Array.isArray(parsed) && parsed.length > 0) {
          return parsed;
        }
      } 
      // If it's already an array, return it
      else if (Array.isArray(cached)) {
        return cached;
      }
      console.warn('Invalid cached trivia format, fetching fresh data');
    }
  } catch (e) {
    console.warn('Error reading from cache:', e);
  }

  const yearSuffix = year ? ` (${year})` : '';
  const prompt = `Provide 5 interesting pieces of trivia about the ${type} "${title}${yearSuffix}". Format your response as a JSON array of strings. Only return the JSON array, no other text or markdown formatting.`;

  try {
    const response = await callGemini([
      {
        role: 'user',
        content: prompt,
      },
    ]);

    let triviaItems: string[] = [];
    
    // First try to parse the response as JSON
    try {
      // Try to extract JSON array if it's wrapped in markdown or other text
      const jsonMatch = response.match(/\[([\s\S]*?)\]/);
      if (jsonMatch) {
        const jsonStr = jsonMatch[0];
        const parsed = JSON.parse(jsonStr);
        if (Array.isArray(parsed)) {
          triviaItems = parsed.filter((item: any) => typeof item === 'string');
        }
      } else {
        // If no array found, try to parse the whole response
        const parsed = JSON.parse(response);
        if (Array.isArray(parsed)) {
          triviaItems = parsed.filter((item: any) => typeof item === 'string');
        } else if (typeof parsed === 'string') {
          triviaItems = [parsed];
        }
      }
    } catch (e) {
      console.warn('Failed to parse trivia as JSON, using as plain text');
      // If all else fails, split by newlines and clean up
      triviaItems = response
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0 && !line.match(/^[\[\]{}]/)); // Remove any JSON artifacts
    }

    // Ensure we have at least one valid trivia item
    if (triviaItems.length === 0) {
      triviaItems = [
        `No trivia available for ${title}${yearSuffix}. Check back later!`,
      ];
    }

    // Format as TriviaFact array
    const triviaFacts = triviaItems.map(fact => ({
      fact,
      category: ['Production', 'Cast', 'Behind the Scenes', 'Fun Fact'][
        Math.floor(Math.random() * 4)
      ] as 'Production' | 'Cast' | 'Behind the Scenes' | 'Fun Fact',
    }));

    // Cache the formatted trivia
    await cache.set(
      CACHE_KEYS.AI_TRIVIA,
      cacheKey,
      JSON.stringify(triviaFacts),
      30 * 24 * 60 * 60 * 1000, // 30 days
    );

    return triviaFacts;
  } catch (error) {
    console.error('Error in getMovieTrivia:', error);
    throw error;
  }
}

// For My Next Watch: get personalized recommendations based on mood
export async function getPersonalizedRecommendation(
  moodAnswers: {[key: string]: string} | null,
  feedbackHistory: Array<{
    contentId: number;
    title: string;
    liked: boolean | null;
    alreadyWatched?: boolean;
    timestamp: number;
  }>
): Promise<any> {
  // Create a cache key based on mood answers and recent feedback
  const cacheKey = `mood:${JSON.stringify(moodAnswers)}:history:${feedbackHistory.length > 0 ? feedbackHistory[0].contentId : 'none'}`;
  
  // Try to get from cache first (shorter TTL since preferences might change)
  const cachedResponse = await cache.get(CACHE_KEYS.AI_RECOMMENDATION, cacheKey);
  if (cachedResponse) {
    return cachedResponse;
  }

  const likedContent = feedbackHistory.filter(f => f.liked === true);
  const dislikedContent = feedbackHistory.filter(f => f.liked === false);
  const alreadyWatchedContent = feedbackHistory.filter(f => f.alreadyWatched === true);
  
  // Get all content IDs that should be excluded from recommendations
  const excludedContentIds = [
    ...alreadyWatchedContent.map(c => c.contentId),
    ...dislikedContent.map(c => c.contentId)
  ];
  
  const system = {
    role: 'system' as const,
    content: `You are Theater AI, a personalized movie/TV recommendation engine. 
      Based on user's current mood/preferences and their feedback history, recommend ONE single movie or TV show that perfectly matches their current state of mind.
      
      Analyze their mood responses deeply to understand what they're truly looking for - not just genres, but emotional tone, pacing, themes, and viewing experience.
      
      Return ONLY a JSON object with these exact fields:
      {"title": "Movie/Show Title", "year": "2024", "type": "movie" or "tv", "description": "A detailed, engaging explanation of why this content perfectly matches their current mood and preferences. Include key themes, emotional tone, pacing, and what makes it compelling for their current state of mind. Make it 2-3 sentences long."}
      
      Do not include any explanation or extra text. Just return the JSON object.`,
  };

  let userPrompt = '';
  
  if (moodAnswers) {
    userPrompt += 'My current mood and preferences:\n';
    Object.entries(moodAnswers).forEach(([questionId, answer]) => {
      const questionMap: {[key: string]: string} = {
        'current_mood': 'How I\'m feeling right now',
        'time_preference': 'How much time I have',
        'energy_level': 'My current energy level'
      };
      userPrompt += `- ${questionMap[questionId] || questionId}: ${answer}\n`;
    });
    userPrompt += '\n';
  }
  
  if (likedContent.length > 0) {
    userPrompt += `Content I previously enjoyed:\n${likedContent.map(c => `- ${c.title}`).join('\n')}\n\n`;
  }
  
  if (dislikedContent.length > 0) {
    userPrompt += `Content I didn't enjoy:\n${dislikedContent.map(c => `- ${c.title}`).join('\n')}\n\n`;
  }
  
  if (alreadyWatchedContent.length > 0) {
    userPrompt += `Content I've already watched:\n${alreadyWatchedContent.map(c => `- ${c.title}`).join('\n')}\n\n`;
  }
  
  userPrompt += 'Based on my current mood and viewing history, recommend ONE movie or TV show that would be perfect for me right now. ';
  
  if (excludedContentIds.length > 0) {
    userPrompt += 'IMPORTANT: Do not recommend any content I have already watched or disliked.';
  }

  const user = {
    role: 'user' as const,
    content: userPrompt,
  };

  try {
    const result = await callGemini([system, user]);
    
    // Try to extract JSON from the response
    const jsonMatch = result.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const aiRecommendation = JSON.parse(jsonMatch[0]);
      
      // Now search TMDB for the actual content data
      let tmdbData = null;
      if (aiRecommendation.type === 'movie') {
        const data = await searchMovies(aiRecommendation.title, 1, {
          year: aiRecommendation.year,
        } as any);
        tmdbData = data?.results && data.results.length > 0 ? data.results[0] : null;
      } else if (aiRecommendation.type === 'tv') {
        const data = await searchTVShows(aiRecommendation.title, 1, {
          first_air_date_year: aiRecommendation.year,
        } as any);
        tmdbData = data?.results && data.results.length > 0 ? data.results[0] : null;
      }
      
      if (tmdbData) {
        return {
          id: tmdbData.id,
          title: tmdbData.title,
          name: tmdbData.name,
          overview: aiRecommendation.description || tmdbData.overview, // Use AI description first
          poster_path: tmdbData.poster_path,
          backdrop_path: tmdbData.backdrop_path,
          vote_average: tmdbData.vote_average,
          release_date: tmdbData.release_date,
          first_air_date: tmdbData.first_air_date,
          genre_ids: tmdbData.genre_ids || [],
          media_type: aiRecommendation.type,
        };
      }
    }

    return null;
  } catch (error) {
    console.error('Error getting personalized recommendation:', error);
    return null;
  }
}
