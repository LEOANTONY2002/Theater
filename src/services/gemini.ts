import {AISettingsManager} from '../store/aiSettings';

// Default fallback values
const DEFAULT_MODEL = 'gemini-2.5-flash';
const DEFAULT_API_KEY = 'AIzaSyA_up-9FqMhzaUxhSj3wEry5qOELtTva_8';

// Dynamic function to get current settings
const getGeminiConfig = async () => {
  try {
    const settings = await AISettingsManager.getSettings();

    return {
      model: settings.model || DEFAULT_MODEL,
      apiKey: settings.apiKey || DEFAULT_API_KEY,
      apiUrl: `https://generativelanguage.googleapis.com/v1beta/models/${
        settings.model || DEFAULT_MODEL
      }:generateContent`,
    };
  } catch (error) {
    console.error('Error getting AI settings, using defaults:', error);
    return {
      model: DEFAULT_MODEL,
      apiKey: DEFAULT_API_KEY,
      apiUrl: `https://generativelanguage.googleapis.com/v1beta/models/${DEFAULT_MODEL}:generateContent`,
    };
  }
};

interface GeminiMessage {
  role: 'user' | 'model';
  parts: Array<{text: string}>;
}

interface OpenAIMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

// Convert OpenAI-style messages to Gemini format
function convertMessagesToGemini(messages: OpenAIMessage[]): {
  systemInstruction?: {parts: Array<{text: string}>};
  contents: GeminiMessage[];
} {
  const systemMessages = messages.filter(msg => msg.role === 'system');
  const conversationMessages = messages.filter(msg => msg.role !== 'system');

  // Combine system messages
  const systemInstruction =
    systemMessages.length > 0
      ? {
          parts: [
            {
              text: systemMessages.map(msg => msg.content).join('\n\n'),
            },
          ],
        }
      : undefined;

  // Convert conversation messages
  const contents: GeminiMessage[] = conversationMessages.map(msg => ({
    role: msg.role === 'assistant' ? 'model' : 'user',
    parts: [{text: msg.content}],
  }));

  return {systemInstruction, contents};
}

async function callGemini(messages: OpenAIMessage[]): Promise<string> {
  const config = await getGeminiConfig();
  const {systemInstruction, contents} = convertMessagesToGemini(messages);

  const requestBody: any = {
    contents,
    generationConfig: {
      temperature: 0.7,
      topK: 40,
      topP: 0.95,
    },
    safetySettings: [
      {
        category: 'HARM_CATEGORY_HARASSMENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_HATE_SPEECH',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
    ],
  };

  if (systemInstruction) {
    requestBody.systemInstruction = systemInstruction;
  }

  try {
    const response = await fetch(`${config.apiUrl}?key=${config.apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      throw new Error(`${response?.status}`);
    }

    const data = await response.json();

    // Extract the generated text from Gemini response
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!generatedText) {
      throw new Error('No content generated by Gemini');
    }

    return generatedText;
  } catch (error) {
    console.error('Gemini API call failed:', error);
    throw error;
  }
}

// For Movie/Show Details: get similar by story
export async function getSimilarByStory({
  title,
  overview,
  genres,
  type,
}: {
  title: string;
  overview: string;
  genres: string;
  type: 'movie' | 'tv';
}) {
  const system = {
    role: 'system' as const,
    content: `You are a movie/TV recommender called Theater AI. 
      Given a title, genres and story, give the most similar movie/show. 
      Return a JSON array of title and year up to 5 similar movies or TV shows. 
      Do not include any explanation or extra text. Just return the JSON array.
      Response Format: [{"title": "Title1", "year": "2024"}, {"title": "Title2", "year": "2025"}]`,
  };
  const user = {
    role: 'user' as const,
    content: `Title: ${title}\nStory: ${overview}\nType: ${type}\nGenres: ${genres}`,
  };

  try {
    const result = await callGemini([system, user]);

    // Try to extract JSON from the response
    const jsonMatch = result.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0]);
      return Array.isArray(parsed) ? parsed : [];
    }

    // If no JSON array found, try to parse the entire response
    const parsed = JSON.parse(result);
    return Array.isArray(parsed) ? parsed : [];
  } catch (error) {
    console.error('Error parsing Gemini similar response:', error);
    return [];
  }
}

// For Online AI Chat (cinema only)
export async function cinemaChat(
  messages: {role: 'user' | 'assistant'; content: string}[],
) {
  const system = {
    role: 'system' as const,
    content: `You are an expert cinema assistant called Theater AI. 
      Only answer questions related to movies, TV, actors, directors, film history, and cinema. 
      Politely refuse unrelated questions. 
      Whenever you suggest any movies/TV shows, always include the tmdb title, year, type in a array only at the last line of the message response.
      whatever the content you are suggesting or talking about should be their correct tmdb details included in the JSON array. And the array should be the last line of the WHOLE RESPONSE, Dont include multiple arrays in every single content.
      JSON Format: [{"title": "Title1", "year": "2024", "type": "movie"}, {"title": "Title2", "year": "2025", "type": "tv"}].
      `,
  };

  const geminiMessages = [system, ...messages];
  const res = await callGemini(geminiMessages);
  let arr = [];

  // Try to extract JSON from the response
  const jsonMatch = res.match(/\[.*?\]/s);
  console.log('jsonMatch', jsonMatch);

  if (jsonMatch) {
    arr = JSON.parse(jsonMatch[0] || '[]');
  }

  // AI Response without JSON
  const aiResponse = res.replace(/\[.*?\]/s, '');

  return {aiResponse, arr};
}

// For Movie/TV Trivia & Facts
export async function getMovieTrivia({
  title,
  year,
  type,
}: {
  title: string;
  year?: string;
  type: 'movie' | 'tv';
}) {
  const system = {
    role: 'system' as const,
    content: `You are Theater AI, an expert in movie and TV trivia. 
      Generate 3-4 interesting, lesser-known facts about the given ${type}.
      Include behind-the-scenes information, production trivia, cast facts, or interesting details.
      
      Return ONLY a JSON array of fact objects:
      [{"fact": "Interesting trivia fact here", "category": "Production" | "Cast" | "Behind the Scenes" | "Fun Fact"}]
      
      Do not include any explanation or extra text. Just return the JSON array.`,
  };

  const user = {
    role: 'user' as const,
    content: `${type === 'movie' ? 'Movie' : 'TV Show'}: ${title}${year ? ` (${year})` : ''}`,
  };

  try {
    const result = await callGemini([system, user]);
    
    // Try to extract JSON from the response
    const jsonMatch = result.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0]);
      return Array.isArray(parsed) ? parsed : [];
    }

    // If no JSON array found, try to parse the entire response
    const parsed = JSON.parse(result);
    return Array.isArray(parsed) ? parsed : [];
  } catch (error) {
    console.error('Error parsing trivia response:', error);
    return [];
  }
}

// For My Next Watch: get personalized recommendations
export async function getPersonalizedRecommendation(
  favoriteGenres: string[],
  feedbackHistory: Array<{
    contentId: number;
    title: string;
    liked: boolean;
    genres: string[];
    timestamp: number;
  }>
): Promise<any> {
  const likedContent = feedbackHistory.filter(f => f.liked);
  const dislikedContent = feedbackHistory.filter(f => !f.liked);
  
  const system = {
    role: 'system' as const,
    content: `You are Theater AI, a personalized movie/TV recommendation engine. 
      Based on user's favorite genres and their feedback history, recommend ONE single movie or TV show.
      
      Return ONLY a JSON object with these exact fields:
      {"title": "Movie/Show Title", "year": "2024", "type": "movie" or "tv", "description": "A detailed, engaging plot summary that explains why this content matches the user's preferences. Include key themes, tone, and what makes it compelling. Make it 2-3 sentences long."}
      
      Do not include any explanation or extra text. Just return the JSON object.`,
  };

  let userPrompt = `Favorite genres: ${favoriteGenres.join(', ')}\n\n`;
  
  if (likedContent.length > 0) {
    userPrompt += `Content I liked:\n${likedContent.map(c => `- ${c.title} (${c.genres.join(', ')})`).join('\n')}\n\n`;
  }
  
  if (dislikedContent.length > 0) {
    userPrompt += `Content I didn't like:\n${dislikedContent.map(c => `- ${c.title} (${c.genres.join(', ')})`).join('\n')}\n\n`;
  }
  
  userPrompt += 'Recommend ONE movie or TV show that I would enjoy based on my preferences.';

  const user = {
    role: 'user' as const,
    content: userPrompt,
  };

  try {
    const result = await callGemini([system, user]);
    
    // Try to extract JSON from the response
    const jsonMatch = result.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const aiRecommendation = JSON.parse(jsonMatch[0]);
      
      // Now search TMDB for the actual content data
      let tmdbData = null;
      if (aiRecommendation.type === 'movie') {
        const res = await fetch(
          `https://api.themoviedb.org/3/search/movie?api_key=ddc242ac9b33e6c9054b5193c541ffbb&query=${encodeURIComponent(
            aiRecommendation.title,
          )}&year=${aiRecommendation.year}`,
        );
        const data = await res.json();
        tmdbData = data.results && data.results.length > 0 ? data.results[0] : null;
      } else if (aiRecommendation.type === 'tv') {
        const res = await fetch(
          `https://api.themoviedb.org/3/search/tv?api_key=ddc242ac9b33e6c9054b5193c541ffbb&query=${encodeURIComponent(
            aiRecommendation.title,
          )}&first_air_date_year=${aiRecommendation.year}`,
        );
        const data = await res.json();
        tmdbData = data.results && data.results.length > 0 ? data.results[0] : null;
      }
      
      if (tmdbData) {
        return {
          id: tmdbData.id,
          title: tmdbData.title,
          name: tmdbData.name,
          overview: aiRecommendation.description || tmdbData.overview, // Use AI description first
          poster_path: tmdbData.poster_path,
          backdrop_path: tmdbData.backdrop_path,
          vote_average: tmdbData.vote_average,
          release_date: tmdbData.release_date,
          first_air_date: tmdbData.first_air_date,
          genre_ids: tmdbData.genre_ids || [],
          media_type: aiRecommendation.type,
        };
      }
    }

    return null;
  } catch (error) {
    console.error('Error getting personalized recommendation:', error);
    return null;
  }
}
