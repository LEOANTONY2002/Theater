import {Platform} from 'react-native';
import {AISettingsManager} from '../store/aiSettings';

// Default fallback values
const DEFAULT_MODEL = 'gemini-2.5-flash';
const DEFAULT_API_KEY = 'AIzaSyBNUXbNTw9EPA5ixGxStNtAAMZLUo4f3xs';

// Dynamic function to get current settings
const getGeminiConfig = async () => {
  try {
    const settings = await AISettingsManager.getSettings();

    return {
      model: settings.model || DEFAULT_MODEL,
      apiKey: settings.apiKey || DEFAULT_API_KEY,
      apiUrl: `https://generativelanguage.googleapis.com/v1beta/models/${
        settings.model || DEFAULT_MODEL
      }:generateContent`,
    };
  } catch (error) {
    console.error('Error getting AI settings, using defaults:', error);
    return {
      model: DEFAULT_MODEL,
      apiKey: DEFAULT_API_KEY,
      apiUrl: `https://generativelanguage.googleapis.com/v1beta/models/${DEFAULT_MODEL}:generateContent`,
    };
  }
};

interface GeminiMessage {
  role: 'user' | 'model';
  parts: Array<{text: string}>;
}

interface OpenAIMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

// Convert OpenAI-style messages to Gemini format
function convertMessagesToGemini(messages: OpenAIMessage[]): {
  systemInstruction?: {parts: Array<{text: string}>};
  contents: GeminiMessage[];
} {
  const systemMessages = messages.filter(msg => msg.role === 'system');
  const conversationMessages = messages.filter(msg => msg.role !== 'system');

  // Combine system messages
  const systemInstruction =
    systemMessages.length > 0
      ? {
          parts: [
            {
              text: systemMessages.map(msg => msg.content).join('\n\n'),
            },
          ],
        }
      : undefined;

  // Convert conversation messages
  const contents: GeminiMessage[] = conversationMessages.map(msg => ({
    role: msg.role === 'assistant' ? 'model' : 'user',
    parts: [{text: msg.content}],
  }));

  return {systemInstruction, contents};
}

async function callGemini(messages: OpenAIMessage[]): Promise<string> {
  const config = await getGeminiConfig();
  const {systemInstruction, contents} = convertMessagesToGemini(messages);

  const requestBody: any = {
    contents,
    generationConfig: {
      temperature: 0.7,
      topK: 40,
      topP: 0.95,
      maxOutputTokens: 2048,
    },
    safetySettings: [
      {
        category: 'HARM_CATEGORY_HARASSMENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_HATE_SPEECH',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
    ],
  };

  if (systemInstruction) {
    requestBody.systemInstruction = systemInstruction;
  }

  try {
    const response = await fetch(`${config.apiUrl}?key=${config.apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.statusText}`);
    }

    const data = await response.json();

    // Extract the generated text from Gemini response
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!generatedText) {
      throw new Error('No content generated by Gemini');
    }

    return generatedText;
  } catch (error) {
    console.error('Gemini API call failed:', error);
    throw error;
  }
}

// For Movie/Show Details: get similar by story
export async function getSimilarByStory({
  title,
  overview,
  genres,
  type,
}: {
  title: string;
  overview: string;
  genres: string;
  type: 'movie' | 'tv';
}) {
  const system = {
    role: 'system' as const,
    content: `You are a movie/TV recommender. 
      Given a title, genres and story, give the most similar movie/show. 
      Return a JSON array of title and year up to 5 similar movies or TV shows. 
      Do not include any explanation or extra text. Just return the JSON array.
      Response Format: [{"title": "Title1", "year": "2024"}, {"title": "Title2", "year": "2025"}]`,
  };
  const user = {
    role: 'user' as const,
    content: `Title: ${title}\nStory: ${overview}\nType: ${type}\nGenres: ${genres}`,
  };

  try {
    const result = await callGemini([system, user]);

    // Try to extract JSON from the response
    const jsonMatch = result.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0]);
      return Array.isArray(parsed) ? parsed : [];
    }

    // If no JSON array found, try to parse the entire response
    const parsed = JSON.parse(result);
    return Array.isArray(parsed) ? parsed : [];
  } catch (error) {
    console.error('Error parsing Gemini similar response:', error);
    return [];
  }
}

// For Online AI Chat (cinema only)
export async function cinemaChat(
  messages: {role: 'user' | 'assistant'; content: string}[],
) {
  const system = {
    role: 'system' as const,
    content: `You are an expert cinema assistant. 
      Only answer questions related to movies, TV, actors, directors, film history, and cinema. 
      Politely refuse unrelated questions. 
      Whenever you suggest any movies/TV shows, always include the tmdb title, year, type in a array only at the last line of the message response.
      whatever the content you are suggesting or talking about should be their correct tmdb details included in the JSON array. And the array should be the last line of the WHOLE RESPONSE, Dont include multiple arrays in every single content.
      JSON Format: TMDB_CONTENT_RESULTS=[{"title": "Title1", "year": "2024", "type": "movie"}, {"title": "Title2", "year": "2025", "type": "tv"}].
      `,
  };

  const geminiMessages = [system, ...messages];
  const res = await callGemini(geminiMessages);
  let arr = [];

  // Try to extract JSON from the response
  const jsonMatch = res.match(/TMDB_CONTENT_RESULTS=(\[.*?\])/s);
  if (jsonMatch) {
    arr = JSON.parse(jsonMatch[1] || '[]');
  }

  // AI Response without JSON
  const aiResponse = res.replace(/TMDB_CONTENT_RESULTS=(\[.*?\])/s, '');

  return {aiResponse, arr};
}
